# 重传机制

## 超时重传

原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的 ACK 报文，那么就重新发送数据，直到发送成功为止。

### RTT

**RTT（Round-Trip Time，往返时间）**。数据包一次的往返时间。

![image.png](https://s2.loli.net/2025/07/17/kfySnEVjqzm8MKR.png)

SRTT：平均的RTT

### 缺点

- 当一个报文丢失时，会**等待一定的超时周期**，才重传分组，增加了**端到端的时延**。
- 当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。
- 并且，对于 TCP，如果**发生一次超时重传**，**时间间隔下次就会加倍**。

## 快速重传

TCP 还有另外⼀种快速重传（**Fast Retransmit**）机制，它不以时间为驱动，⽽是以数据驱动重传。

![image.png](https://s2.loli.net/2025/07/17/zr5SZwTUIaG4Lte.png)

- 当seq2丢失之后，虽然接收方收到了seq3、seq4、seq5，但是接收方依然回复给发送方ACK=2。
- 发送方在收到三个ACK=2之后，就会触发快速重传。重传seq2。
- 而接收方在收到seq2之后，可以直接返回ACK=6。

快速重传解决了超时等待的问题，但是引入了一个新的问题。

就是不确定seq2之后的数据是否成功了。因为返回的都是ACK2，所以在重传的时候会面临重传seq2，还是重传seq2包括之后所有的数据。

### SACK

为了解决应该重传哪些包，TCP提供了带选择确认的重传，**SACK**。

![image.png](https://s2.loli.net/2025/07/17/njHPN6tflqQVyb7.png)

在快速重传基础上，**接收方返回最近收到报文段的序列号范围**。

这样发送方能够确认哪些数据包是没收到的，就清楚应该重传哪些数据包。

*如上图中，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重发。*

### Duplicate-SACK

假如发送方发的数据接收方收到了，但是接收方在返回ACK的时候丢了。

这个时候发送方就会发送重复数据给接收方。而接收方在收到重复数据后，会返回D-SACK标志给发送方，能够让发送方判断出来数据重复的部分。

![image.png](https://s2.loli.net/2025/07/17/UoGR4ALJ8OQD3Ic.png)

- ACK包丢失导致的重复发送问题。